     1                                  ; Join!
     2                                  
     3                                  [map all ./lst/join.map]
     4                                  [DEFAULT REL]
     5                                  
     6                                  ;
     7                                  ;Creates, deletes and displays join drives.
     8                                  ;Order of arguments DOES NOT matter.
     9                                  ;Invoked by: 
    10                                  ; JOIN [drive 1: drive2:path] <- Mounts drive1 onto the path at drive2:path
    11                                  ; JOIN drive1: /D       <- Deletes the join drive drive1:
    12                                  ; JOIN                  <- Displays current join drives
    13                                  
    14                                  BITS 64
    15                                  %include "./inc/dosMacro.mac"
     1                              <1> 
     2                              <1> ;-------------------------------------------------------------------------------
     3                              <1> ;Generic Macros file
     4                              <1> ;The following instruction extensions allow to conditionally return
     5                              <1> ;The idea was borrowed from the DOS Source Code
     6                              <1> ;
     7                              <1> ;-------------------------------------------------------------------------------
     8                              <1> 
     9                              <1> ;-------------------------------------------------------------------------------
    10                              <1> ;These macros are live and must not be touched
    11                              <1> ;-------------------------------------------------------------------------------
    12                              <1> %macro return 0
    13                              <1> %%_ret:
    14                              <1>     ret
    15                              <1> %assign retOff %%_ret-$$  ;Get offset into segment of %%_ret
    16                              <1> %endmacro
    17                              <1> 
    18                              <1> %macro cret 1
    19                              <1> %%_base:
    20                              <1> %assign baseVar %%_base-$$ ;Get offset into segment of %%_base
    21                              <1>     %ifdef retOff
    22                              <1>     %if (baseVar - retOff <= 126) && (baseVar > retOff)
    23                              <1>     %ifdef currSegVBase
    24                              <1>     j%+1 short (retOff+currSegVBase)
    25                              <1>     %else
    26                              <1>     j%+1 short retOff
    27                              <1>     %endif  ;End ifdef currSegVBase
    28                              <1>     %else 
    29                              <1>     j%-1 short %%a
    30                              <1>     return
    31                              <1> %%a:
    32                              <1>     %endif  ;End the distance measurement if
    33                              <1>     %else   
    34                              <1>     j%-1 short %%a
    35                              <1>     return
    36                              <1> %%a:
    37                              <1>     %endif  ;End ifdef retoff
    38                              <1> %endmacro
    39                              <1> 
    40                              <1> %macro retz 0
    41                              <1> cret z
    42                              <1> %endmacro
    43                              <1> 
    44                              <1> %macro retnz 0
    45                              <1> cret nz
    46                              <1> %endmacro
    47                              <1> 
    48                              <1> %macro rete 0
    49                              <1> cret e
    50                              <1> %endmacro
    51                              <1> 
    52                              <1> %macro retne 0
    53                              <1> cret ne
    54                              <1> %endmacro
    55                              <1> 
    56                              <1> %macro retc 0
    57                              <1> cret c
    58                              <1> %endmacro
    59                              <1> 
    60                              <1> %macro retnc 0
    61                              <1> cret nc
    62                              <1> %endmacro
    63                              <1> 
    64                              <1> %macro retb 0
    65                              <1> cret b
    66                              <1> %endmacro
    67                              <1> 
    68                              <1> %macro retnb 0
    69                              <1> cret nb
    70                              <1> %endmacro
    71                              <1> 
    72                              <1> %macro reta 0
    73                              <1> cret a
    74                              <1> %endmacro
    75                              <1> 
    76                              <1> %macro retna 0
    77                              <1> cret na
    78                              <1> %endmacro
    79                              <1> 
    80                              <1> %macro breakpoint 0
    81                              <1> xchg bx, bx
    82                              <1> %endmacro
    16                                  %include "./inc/dosStruc.inc"
     1                              <1> 
     2                              <1> ;-------------------------------------------------------;
     3                              <1> ; This include file contains miscellaneous internal     ;
     4                              <1> ; SCP/DOS structures.                                   ;
     5                              <1> ;-------------------------------------------------------;
     6                              <1> 
     7                              <1> ;------------------------------------------------------------------------;
     8                              <1> ; Each mass storage device up to LASTDRIVE gets a DPB, describing 
     9                              <1> ; its file system structure. This is used to locate files and structures
    10                              <1> ; on the device itself and to translate file requests to cluster chains
    11                              <1> ; to LBAs to pass to the disk driver..
    12                              <1> ; The DPBs form a linked list, with each DPB formed after the devices 
    13                              <1> ; drivers Initialise routine has been called.
    14                              <1> ;------------------------------------------------------------------------;
    15                              <1> struc dpb        ;Drive Parameter Block
    16                              <1> 
    17 00000000 ??                  <1>     .bDriveNumber            db ?  ;Drive number (0=A, 1=B ...)
    18 00000001 ??                  <1>     .bUnitNumber             db ?  ;Unit number in device
    19 00000002 ????                <1>     .wBytesPerSector         dw ?  ;min 512, max 4096
    20 00000004 ??                  <1>     .bMaxSectorInCluster     db ?  ;(Maximum sector in cluster) - 1
    21 00000005 ??                  <1>     .bSectorsPerClusterShift db ?  ;Sectors per cluster exponent
    22 00000006 ????                <1>     .wFAToffset              dw ?  ;Number of reserved sectors in partition
    23 00000008 ??                  <1>     .bNumberOfFATs           db ?  ;Number of FATs
    24 00000009 ????                <1>     .wNumberRootDirEntries   dw ?  ;In 32 byte units, this is 0 for FAT32
    25 0000000B ????????            <1>     .dClusterHeapOffset      dd ?  ;Start sector of data area
    26 0000000F ????????            <1>     .dClusterCount           dd ?  ;Total number of clusters in data area
    27 00000013 ????????            <1>     .dFATlength              dd ?  ;FAT length, in sectors
    28 00000017 ????????            <1>     .dFirstUnitOfRootDir     dd ?  
    29                              <1>     ;Unit=Sector/Cluster of Root Directory (FAT12/16 = Sector, FAT32 = Cluster)
    30 0000001B ????????????????    <1>     .qDriverHeaderPtr        dq ?  ;Pointer to device driver header
    31 00000023 ??                  <1>     .bMediaDescriptor        db ?  ;Media descriptor
    32 00000024 ??                  <1>     .bAccessFlag             db ?  ;Access Flag (0 if accessed, else -1)
    33 00000025 ????????????????    <1>     .qNextDPBPtr             dq ?  ;Pointer to next DPB, -1 if at end
    34 0000002D ????????            <1>     .dFirstFreeCluster       dd ?  ;Starting cluster of free space search
    35 00000031 ????????            <1>     .dNumberOfFreeClusters   dd ?  ;Number of free clusters, -1 unknown
    36                              <1> 
    37                              <1> endstruc
    38                              <1> 
    39                              <1> fat12MaxClustCnt    equ 4085    ;Cluster count less than this is FAT12
    40                              <1> fat16MaxClustCnt    equ 65525   ;Cluster count less than this is FAT16
    41                              <1> ;------------------------------------------------------------------------;
    42                              <1> ; Each mass storage device up to LASTDRIVE has a CDS associated with it.
    43                              <1> ; All disk pathing requests go via the CDS for that drive.
    44                              <1> ; The default drive is the last accessed drive, this number is stored
    45                              <1> ; in the DOS data area.
    46                              <1> ; The CDS is stored as an array with the offset into the array being 
    47                              <1> ; given by the drive letter's offset into the alphabet (with A=0).
    48                              <1> ;
    49                              <1> ; DEFAULT LASTDRIVE=E, MINIMUM LASTDRIVE=B
    50                              <1> ;------------------------------------------------------------------------;
    51                              <1> struc cds       ;Current Directory structure
    52 00000000 <res 43h>           <1>     .sCurrentPath        db 67 dup (?)    ;Current Directory Path String
    53 00000043 ????                <1>     .wFlags              dw ?   ;CDS Flags - 
    54 00000045 ????????????????    <1>     .qDPBPtr             dq ?   ;Ptr to the DPB of the dev using this CDS
    55 0000004D ????????            <1>     .dStartCluster       dd ?   ;Starting cluster of the directory on disk
    56 00000051 ????????????????    <1>     .qIFSPtr             dq ?   ;Reserved for IFS driver expansions
    57 00000059 ????????            <1>     .dNetStore           dd ?   ;For storing a owner dword for IFS (21h/5F03h)
    58 0000005D ????                <1>     .wBackslashOffset    dw ?   ;How many chars to skip for getting the path
    59                              <1> ; currentPath (usually 2 to skip C: in C:\, but when SUBSTing a drive letter to 
    60                              <1> ; another, we save the number of chars to skip to that deep level).
    61                              <1> ; I.E. if we SUBST A:\DOS G: then this value for the CDS for drive G is 6
    62                              <1> ; Only affects for SUBST drives, not JOIN
    63                              <1> ; Flags: Bit 15 set = Network drive
    64                              <1> ;        Bit 14 set = Physical drive
    65                              <1> ;        Bit 13 set = JOIN'ed drive
    66                              <1> ;        Bit 12 set = SUBST'ed drive
    67                              <1> ;        Bit 7  set = Redirected, not net. drive (This is how MSCDEX worked)
    68                              <1> endstruc
    69                              <1> ;CDS equates
    70                              <1> cdsRedirDrive   equ 8000h   ;All drives which use the Redirector interface
    71                              <1> cdsValidDrive   equ 4000h   ;CDS valid
    72                              <1> cdsJoinDrive    equ 2000h   ;CDS for joined drives
    73                              <1> cdsSubstDrive   equ 1000h   ;Drives formed by Subst
    74                              <1> cdsRdirLocDrive equ 0080h   ;Redirector but Local
    75                              <1> ;------------------------------------------------------------------------;
    76                              <1> ; The SFT is a way to allow applications to open file handles to files 
    77                              <1> ; and devices. As things stand, the SFT chain will have 5 file handles
    78                              <1> ; under the first header, and then a second header will be linked to the 
    79                              <1> ; first one after CONFIG.SYS has been read, to allow for FILES= to specify
    80                              <1> ; a size for the second SFT (default 10 files). Same for System FCBs, 
    81                              <1> ; using the FCBS= command. Default FCBS=5.
    82                              <1> ;
    83                              <1> ; A file handle describes the file, and the location within the file that
    84                              <1> ; we are reading. The file handle can be manipulated without the file
    85                              <1> ; being in memory, thus allowing the user to access data without needing 
    86                              <1> ; to take up large portions of memory. Similarly, file handles allow for
    87                              <1> ; accessing devices, by treating them as files with their drivers 
    88                              <1> ; responding and translating the manipulations of the file handle itself.
    89                              <1> ; Neither the driver nor the application should see or use the SFT for
    90                              <1> ; the handle, as it is subject to change (and will change when file 
    91                              <1> ; sharing provisions are included). The DOS will make requests to the 
    92                              <1> ; driver in a generic way and the driver will respond, with DOS keeping
    93                              <1> ; track of the information in the SFT entry for that handle. 
    94                              <1> ;
    95                              <1> ; One SFT entry can have multiple handles and multiple SFT entries
    96                              <1> ; can point to the same file. It all depends on what the applications 
    97                              <1> ; want to do with the File.
    98                              <1> ;
    99                              <1> ; !!!!IMPORTANT!!!!
   100                              <1> ; Currently there are plans for File Sharing, but I include minimal 
   101                              <1> ; provisions for it. I really just wanna get a DOS out the door.
   102                              <1> ;
   103                              <1> ;Each SFT may look like this:
   104                              <1> ;sysvars-->sfth------------>sfth------------>|ENDOFLIST|
   105                              <1> ;            |                |
   106                              <1> ;       wNumFiles*sft    wNumFiles*sft
   107                              <1> ;
   108                              <1> ; Two SFT chains are built; one for files, and a one for so called 
   109                              <1> ; System FCBs.
   110                              <1> ;
   111                              <1> ; Each SFT header has an array of SFT's below it, with the number of 
   112                              <1> ; SFTs given by wNumFiles. The SFT headers form a linked list.
   113                              <1> ;
   114                              <1> ; DEFAULT FILES=8, MINIMUM FILES=5
   115                              <1> ; DEFAULT FCBS=5,  MINIMUM FCBS=5
   116                              <1> ;------------------------------------------------------------------------;
   117                              <1> struc sfth   ;System file table header
   118                              <1> ; This is the SFT header.
   119                              <1> ; This structure comes before the start of the first file in the array/table.
   120 00000000 ????????????????    <1>     .qNextSFTPtr dq ?    ;Pointer to the next SFT
   121 00000008 ????                <1>     .wNumFiles   dw ?    ;Number of files in this table
   122                              <1> endstruc
   123                              <1> 
   124                              <1> struc sft
   125                              <1> ;This is the file struc itself
   126 00000000 ????                <1>     .wNumHandles dw ?    ;Number of handles pointing to this file
   127 00000002 ????                <1>     .wOpenMode   dw ?    ;File access permissions and behvaiours
   128 00000004 ??                  <1>     .bFileAttrib db ?    ;Regular File Attributes
   129 00000005 ????                <1>     .wDeviceInfo dw ?    ;Includes unit number if a block device
   130 00000007 ????????????????    <1>     .qPtr        dq ?    ;IF char, ptr to device driver header, ELSE DPBptr
   131 0000000F ????????            <1>     .dStartClust dd ?    ;Start cluster of file pointed to by SFT entry
   132 00000013 ????                <1>     .wTime       dw ?    ;File Time, updated on open and writes
   133 00000015 ????                <1>     .wDate       dw ?    ;File Date, updated on open and writes
   134 00000017 ????????            <1>     .dFileSize   dd ?    ;File Size, in bytes
   135 0000001B ????????            <1>     .dCurntOff   dd ?    ;Current Offset pointed to by SFT entry, in bytes
   136 0000001F ????????            <1>     .dRelClust   dd ?    ;Rel cluster pointed to by SFT entry
   137 00000023 ????????            <1>     .dAbsClusr   dd ?    ;Absolute cluster pointed to by SFT entry
   138 00000027 ????????????????    <1>     .qDirSect    dq ?    ;Abs number of sector containing directory entry 
   139 0000002F ??                  <1>     .bNumDirEnt  db ?    ;Directory entry within dir sector (byte offset/32)
   140 00000030 <res Bh>            <1>     .sFileName   db 11 dup (?)   ;8.3 Filename
   141 0000003B ????????????????    <1>     .qSharePtr   dq ?    ;SHARE pointer to previous SFT sharing same file
   142 00000043 ????                <1>     .wMachNum    dw ?    ;SHARE number of network machine opening file
   143 00000045 ????????????????    <1>     .qPSPOwner   dq ?    ;Addr of PSP of program which first opened this file
   144 0000004D ????                <1>     .wShareRec   dw ?    ;offset within SHARE code segment of sharing record
   145                              <1> ;                           0 means no record
   146                              <1> endstruc
   147                              <1> ;Open Mode equates
   148                              <1> ;Access modes   Bits[2:0]
   149                              <1> ReadAccess      equ 0h
   150                              <1> WriteAccess     equ 1h
   151                              <1> RWAccess        equ 2h
   152                              <1> ;Bit 3 reserved 0
   153                              <1> ;Sharing modes  Bits[6:4]
   154                              <1> CompatShare     equ 0h
   155                              <1> denyRWShare     equ 10h
   156                              <1> denyWriteShare  equ 20h
   157                              <1> denyReadShare   equ 30h
   158                              <1> denyNoneShare   equ 40h
   159                              <1> ;NetFCB is for files open by a local server, handling IO from a remote
   160                              <1> ; client by proxy opened by an FCB! Sets the Net bit to indicate this. 
   161                              <1> ;Thus, this is a handle with no JFT entry! Server handles its own JFT!
   162                              <1> netFCBShare     equ 70h     
   163                              <1> noInherit       equ 80h
   164                              <1> ;Bits 8-12 reserved 0
   165                              <1> ;Fancy open mode bits
   166                              <1> diskFullFail    equ 2000h   ;Reserved: If set, trigger Int 24h on disk full.
   167                              <1> noBufferWrites  equ 4000h   ;Reserved: If set, flush after each buffer write.
   168                              <1> ;Once share is loaded, if a local FCB open occurs, mark the sft as so.
   169                              <1> FCBopenedFile   equ 8000h   ;If set, file is opened by FCB, else handle based.
   170                              <1> 
   171                              <1> ;Attribute Byte
   172                              <1> readOnlyFile    equ 1h
   173                              <1> hiddenFile      equ 2h
   174                              <1> systemFile      equ 4h
   175                              <1> volLabelFile    equ 8h
   176                              <1> directoryFile   equ 10h ;Directory entry
   177                              <1> archiveFile     equ 20h
   178                              <1> charFile        equ 40h ;Reserved, never found in dir
   179                              <1> ;Device Info equates
   180                              <1> ;For a block device, bits [5:0] contain the drive number
   181                              <1> charDevConIn    equ 1h  ;If set, device is CON input
   182                              <1> charDevConOut   equ 2h  ;If set, device is CON output
   183                              <1> charDevNulDev   equ 4h  ;If set, device is NULL device
   184                              <1> charDevClockDev equ 8h  ;If set, device is CLOCK device
   185                              <1> charDevFastOut  equ 10h ;If set, device supports INT 29h
   186                              <1> charDevBinary   equ 20h ;If set, r/w char device in Binary mode!!!
   187                              <1> charDevNoEOF    equ 40h ;If set, no EOF when reading from device!!
   188                              <1> blokFileNoFlush equ 40h ;Set if file is synchronised with hard store!
   189                              <1> devCharDev      equ 80h ;If set, it is a char device!
   190                              <1> charDevNetSpool equ 800h    ;If set, device is a network spooler
   191                              <1> devNoInherit    equ 1000h   ;If set, handle not inherited by child processes
   192                              <1> charDevNamePipe equ 2000h   ;If set, device is a named pipe
   193                              <1> blokNoDTonClose equ 4000h   ;If set, dont update date and time when closing
   194                              <1> devRedirDev     equ 8000h   ;If set, dev/file is redirected!
   195                              <1>  
   196                              <1> ;------------------------------------------------------------------------;
   197                              <1> ; Buffers allow for buffered drive IO, by first transferring a sector 
   198                              <1> ; to an internal buffer, and then copying it to the specified location
   199                              <1> ; in memory. The buffer is kept in the buffer chain,  in the event that 
   200                              <1> ; another request for the same sector from the same device is made, so 
   201                              <1> ; that is can be read from the device directly. Buffers are uniform in 
   202                              <1> ; size, selected according to the largest detected sector size during 
   203                              <1> ; the initial loadup.
   204                              <1> ;
   205                              <1> ; The buffer pointer in SysVars points to most recently used Buffer
   206                              <1> ;
   207                              <1> ; DEFAULT BUFFERS=30, MINIMUM BUFFERS=2
   208                              <1> ;------------------------------------------------------------------------;
   209                              <1> 
   210                              <1> struc bufferHdr
   211 00000000 ????????????????    <1>     .nextBufPtr  dq  ?   ;Pointer to the next buffer in the chain or -1 at end
   212                              <1>     .wDrvNumFlg:         ;Read as a word to get the following two bytes!
   213 00000008 ??                  <1>     .driveNumber db  ?   ;Drive number the buffer is used for (or -1 for free)
   214 00000009 ??                  <1>     .bufferFlags db  ?   ;Standard Flags
   215 0000000A ????????????????    <1>     .bufferLBA   dq  ?   ;LBA the buffer contains
   216 00000012 ??                  <1>     .bufFATcopy  db  ?   ;Number of copies of the FAT to write (1 if non-FAT)
   217 00000013 ????????            <1>     .bufFATsize  dd  ?   ;Number of sectors per FAT (or 0 if non-FAT)
   218 00000017 ????????????????    <1>     .driveDPBPtr dq  ?   ;Pointer to the device DPB block
   219 0000001F ??                  <1>     .reserved    db  ?   ;Alignment byte
   220                              <1>     .dataarea:             ;Points to the start of the data area
   221                              <1> endstruc
   222                              <1> ;Buffer Flag equates
   223                              <1> dosBuffer   equ 1h  ;Sector 0 (BPB/VPB) in buffer
   224                              <1> fatBuffer   equ 2h  ;FAT sector in buffer
   225                              <1> dirBuffer   equ 4h  ;Directory sector in buffer
   226                              <1> dataBuffer  equ 8h  ;File Data sector in buffer
   227                              <1> refBuffer   equ 20h ;Data in buffer has been referenced by an application
   228                              <1> dirtyBuffer equ 40h ;Data in buffer modified by an application
   229                              <1> freeBuffer  equ 00FFh   ;A word which goes into the drive number to clear both fields
   230                              <1> ;Note! A buffer is marked as referenced when the buffer is "obtained" by a syscall
   231                              <1> ;------------------------------------------------------------------------;
   232                              <1> ; Memory control block for each memory arena
   233                              <1> ;------------------------------------------------------------------------;
   234                              <1> struc mcb
   235 00000000 ??                  <1>     .marker     db ?  ;M = Member of the MCB chain. Z = Last member
   236 00000001 ????????????????    <1>     .owner      dq ?  ;Owning application PSP (para aligned) or 0 for free
   237 00000009 ????????            <1>     .blockSize  dd ?  ;Number of contiguous paragraphs owned by this block
   238                              <1>     ;The following byte is reserved outside of sysinit
   239 0000000D ??                  <1>     .subSysMark db ?  ;Marks the optional DOS subsystem of the MCB
   240 0000000E ????                <1>     .reserved   db 2 dup (?) 
   241                              <1>     .program:
   242                              <1> endstruc
   243                              <1> ;MCB equates
   244                              <1> mcbOwnerHole    equ 7   ;Owner = 7 => Memory hole, always fail free/realloc
   245                              <1> mcbOwnerFree    equ 0   ;Owner = 0 => Free and available space
   246                              <1> mcbOwnerDOS     equ 8   ;Owner = 8 => Owned by DOS
   247                              <1> mcbOwnerNewDOS  equ 9   ;Owner = 9 => New Kernel driver alloc. Needs setting to 8.
   248                              <1> mcbMarkCtn      equ "M"
   249                              <1> mcbMarkEnd      equ "Z"
   250                              <1> ;The following are used on MCB's that belong to DOS, that are not part of the
   251                              <1> ; main kernel (i.e. the CONFIG.SYS optional parts).
   252                              <1> mcbSubDriver    equ "D" ;Any memory allocated for a device driver's code.
   253                              <1> mcbSubDrvExtra  equ "L" ;Any memory allocated by a device driver.
   254                              <1> mcbSubDrvDPB    equ "P" ;Blocks used for DPB's are marked so.
   255                              <1> mcbSubIFS       equ "I" ;Unused for now
   256                              <1> mcbSubFiles     equ "F" ;Any memory allocated for Files.
   257                              <1> mcbSubFCBS      equ "X" ;Unused for now
   258                              <1> mcbSubBuffers   equ "B" ;Any memory allocated for Buffers.
   259                              <1> mcbSubCDS       equ "L" ;Any memory allocated to store a CDS.
   260                              <1> mcbSubStacks    equ "S" ;Unused for now
   261                              <1> 
   262                              <1> 
   263                              <1> memFirstFit     equ 0   ;First free block goes to application
   264                              <1> memBestFit      equ 1   ;Block whos size closest matches requirement
   265                              <1> memLastFit      equ 2   ;Last free block goes to application
   266                              <1> 
   267                              <1> ;Owner = Para aligned address => Owning application PSP
   268                              <1> ;...To consider...
   269                              <1> ;Owner = Non-para aligned address => Error? Should maybe lock up system?
   270                              <1> ;blockSize counts the number of paragraphs FROM .program TO THE NEXT MCB!
   271                              <1> ;------------------------------------------------------------------------;
   272                              <1> ; For Int 21h, the callers registers are saved on their stack in the 
   273                              <1> ; following order, thus allowing for return values to be placed in the 
   274                              <1> ; registers by accessing the caller register stack frame.
   275                              <1> ;------------------------------------------------------------------------;
   276                              <1> struc callerFrame
   277 00000000 ????????????????    <1>     .rax    dq ?  ;Bottom of frame, pointer to rax saved in oldRSP
   278 00000008 ????????????????    <1>     .rbx    dq ?    
   279 00000010 ????????????????    <1>     .rcx    dq ?
   280 00000018 ????????????????    <1>     .rdx    dq ?
   281 00000020 ????????????????    <1>     .rsi    dq ?
   282 00000028 ????????????????    <1>     .rdi    dq ?
   283 00000030 ????????????????    <1>     .rbp    dq ?
   284 00000038 ????????????????    <1>     .r8     dq ?  ;To be removed if truly not needed
   285 00000040 ????????????????    <1>     .r9     dq ?
   286                              <1> ;Pushed by Processor when invoked via Interrupt
   287 00000048 ????????????????    <1>     .rip    dq ?
   288 00000050 ????????????????    <1>     .cs     dq ?
   289 00000058 ????????????????    <1>     .flags  dq ?
   290                              <1> endstruc
   291                              <1> 
   292                              <1> struc dpl
   293                              <1> ;DOS parameter list, pointer to this stack is passed to DOS in rdx on
   294                              <1> ; server calls
   295 00000000 ????????????????    <1>     .rax    dq ?
   296 00000008 ????????????????    <1>     .rbx    dq ?
   297 00000010 ????????????????    <1>     .rcx    dq ?
   298 00000018 ????????????????    <1>     .rdx    dq ?
   299 00000020 ????????????????    <1>     .rsi    dq ?
   300 00000028 ????????????????    <1>     .rdi    dq ?
   301 00000030 ????????????????    <1>     .r8     dq ?
   302 00000038 ????????????????    <1>     .r9     dq ?
   303 00000040 ????????????????    <1>     .align  dq ?
   304 00000048 ????????????????    <1>     .compID dq ?  ;Computer id, low word used only
   305 00000050 ????????????????    <1>     .procID dq ?  ;Process ID
   306                              <1> endstruc
   307                              <1> 
   308                              <1> struc cfgFrame  ;Frame used for config.sys parsing
   309 00000000 ????????????????    <1>     .oldRBP         dq ?  ;Ptr to DOSSEG
   310 00000008 ????????????????    <1>     .newBuffers     dq ?  ;New buffers value
   311 00000010 ????????????????    <1>     .newSFTVal      dq ?
   312 00000018 ????????????????    <1>     .newFCBSVal     dq ?
   313 00000020 ????????????????    <1>     .newProtFCBSVal dq ?  ;Number of protected FCBS
   314 00000028 ????????????????    <1>     .newLastdrive   dq ?
   315 00000030 ????????????????    <1>     .newStacks      dq ?  ;Ignored for now
   316 00000038 ????????????????    <1>     .newStackSize   dq ?  ;Ignored for now
   317 00000040 ????????????????    <1>     .cfgHandle      dq ?  ;CONFIG.SYS handle
   318 00000048 ????????????????    <1>     .lastLine       dq ?  ;Set if the last line is current
   319 00000050 ????????????????    <1>     .linePtr        dq ?  ;Ptr to line buffer of line being processed
   320 00000058 ????????????????    <1>     .driverBreak    dq ?  ;Ptr to the pathname terminator 
   321 00000060 ????????????????    <1>     .breakChar      dq ?  ;Char that was replaced by null for terminator
   322                              <1> endstruc
   323                              <1> 
   324                              <1> struc filename
   325                              <1> ;8.3 File name struct
   326 00000000 ????????????????    <1>     .fName  db 8 dup (?)
   327 00000008 ??????              <1>     .fExt   db 3 dup (?)
   328                              <1> endstruc
   329                              <1> 
   330                              <1> struc ffBlock   ;The structure of the Find First structure at the DTA
   331 00000000 ??                  <1>     .driveNum   db ?  ;Drive we are searching on, 1 based number
   332 00000001 <res Bh>            <1>     .template   db 11 dup (?) ;Search template (? meaning anything)
   333 0000000C ??                  <1>     .attrib     db ?  ;Search attribute
   334 0000000D ????????            <1>     .dirOffset  dd ?  ;32 byte entry within dir cluster
   335 00000011 ????????            <1>     .parDirClus dd ?  ;Parent Directory Cluster number
   336 00000015 ??                  <1>     .attribFnd  db ?  ;Attrib of file found
   337 00000016 ????                <1>     .fileTime   dw ?  ;File time
   338 00000018 ????                <1>     .fileDate   dw ?  ;File date
   339 0000001A ????????            <1>     .fileSize   dd ?  ;Number of bytes
   340 0000001E <res Dh>            <1>     .asciizName db 13 dup (?) ;ASCIIZ name with dot and terminating nul
   341                              <1> endstruc
   342                              <1> 
   343                              <1> 
   344                              <1> dfltJFTsize equ 20  ;Default size of PSP JFT
   345                              <1> struc psp
   346 00000000 ????                <1>     .return     db 2 dup (?)  ;Should always be CDh 20h, same place as DOS
   347 00000002 ????????            <1>     .allocSize  dd ?  ;Number of paras in init alloc or when exiting as TSR.
   348 00000006 ????????            <1>                 dd ?  ;Reserved 4 bytes
   349 0000000A ????????????????    <1>     .oldInt22h  dq ?  ;Int 22h pointer on overlay load
   350 00000012 ????????????????    <1>     .oldInt23h  dq ?  ;Int 23h pointer on overlay load
   351 0000001A ????????????????    <1>     .oldInt24h  dq ?  ;Int 24h pointer on overlay load
   352 00000022 ????????????????    <1>     .parentPtr  dq ?  ;Pointer to parent process PSP
   353                              <1> ;If jftSize > 20, then the QWORD at .jobFileTbl becomes a pointer
   354                              <1> ; to the actual in use JFT and the other 12 bytes are left undefined.
   355                              <1> ;If jftSize < 20 (DOS will never set it so), then it is considered as 20
   356                              <1> ;If the user tries to reduce handle count to 20 or less, then the PSP JFT is 
   357                              <1> ; always used and jftSize.
   358                              <1>     .externalJFTPtr:    ;Ptr to external JFT array (first byte AFTER MCB)
   359 0000002A <res 14h>           <1>     .jobFileTbl db dfltJFTsize dup (?) ;Main File handle array, JFT
   360 0000003E ????????????????    <1>     .envPtr     dq ?  ;Pointer to the environment
   361 00000046 ????????????????    <1>     .rspPtr     dq ?  ;Pointer to rsp on entry to Int 21h
   362 0000004E ????                <1>     .jftSize    dw ?  ;JFT array size, 20 => PSP JFT in use
   363 00000050 ??????              <1>     .unixEntry  db 3 dup (?)  ;Must always be CDh 21h CBh, same place as DOS
   364 00000053 ????????????????    <1>     .prevPSP    dq ?  ;Pointer to the previous PSP in chain (used by SHARE)
   365 0000005B ??                  <1>                 db ?  ;Reserved byte
   366                              <1> ;The below are in the same place as in DOS.
   367                              <1>     .cmdLineArgPtr: ;Symbol for future use
   368 0000005C <res 10h>           <1>     .fcb1       db 16 dup (?)  ;First FCB,    argument 1 
   369 0000006C <res 14h>           <1>     .fcb2       db 20 dup (?)  ;Second FCB,   argument 2
   370                              <1>     .dta:   ;Pointer to the default DTA in the PSP
   371 00000080 ??                  <1>     .parmList   db ?   ;Number of characters in command tail
   372 00000081 <res 7Fh>           <1>     .progTail   db 127 dup (?) ;Default DTA/Program tail
   373                              <1> endstruc
   374                              <1> 
   375                              <1> struc clkStruc
   376 00000000 ????                <1>     .dateWord   dw ?
   377 00000002 ??                  <1>     .minutes    db ?
   378 00000003 ??                  <1>     .hours      db ?
   379 00000004 ??                  <1>     .hseconds   db ?  ;Hundreths of seconds
   380 00000005 ??                  <1>     .seconds    db ?
   381                              <1> endstruc
   382                              <1> 
   383                              <1> 
   384                              <1> struc extCtryStruc
   385 00000000 ??                  <1>     .infoIDCode db ?    ;Information ID code (01h)
   386 00000001 ????                <1>     .strucSize  dw ?    ;Length of the structure  (42 or less)
   387 00000003 ????                <1>     .ctryID     dw ?    ;Country ID number
   388 00000005 ????                <1>     .cpNumber   dw ?    ;Code page number
   389 00000007 ????                <1>     .dtfmt      dw ?    ;Date time format (2 bytes)
   390                              <1>                         ;0 = month day year hh:mm:ss
   391                              <1>                         ;1 = day month year hh:mm:ss
   392                              <1>                         ;2 = year month day hh:mm:ss
   393 00000009 ??????????          <1>     .curr       db 5 dup (?)   ;ASCIIZ Currency symbol (5 chars)
   394 0000000E ????                <1>     .thouSep    db 2 dup (?)   ;ASCIIZ Thousands separator
   395 00000010 ????                <1>     .dcmlSep    db 2 dup (?)   ;ASCIIZ Decimal separator
   396 00000012 ????                <1>     .dateSep    db 2 dup (?)   ;ASCIIZ Date separator
   397 00000014 ????                <1>     .timeSep    db 2 dup (?)   ;ASCIIZ Time separator
   398 00000016 ??                  <1>     .currFmt    db ?    ;Currency Format
   399                              <1>                         ;0 = Symbol leads, without space
   400                              <1>                         ;1 = Symbol follows, without space
   401                              <1>                         ;2 = Symbol leads, one space
   402                              <1>                         ;3 = Symbol follows, one space
   403                              <1>                         ;4 = Symbol replace decimal separator
   404 00000017 ??                  <1>     .digtdpt    db ?    ;Number of digits after the decimal point
   405 00000018 ??                  <1>     .timefmt    db ?    ;Time format, Bit 0 = 0 => 12 hour, = 1 => 24 hour clock
   406 00000019 ????????????????    <1>     .mapptr     db 8 dup (?)  ;Case map address (0 is nulptr), needs fixing up
   407 00000021 ????                <1>     .dataSep    db 2 dup (?)  ;Data list separator
   408 00000023 <res Ah>            <1>     .resv       db 10 dup (?) ;Reserve 10 bytes
   409                              <1> endstruc
   410                              <1> 
   411                              <1> struc countryStruc
   412 00000000 ????                <1>     .dtfmt      dw ?    ;Date time format (2 bytes)
   413                              <1>                         ;0 = month day year hh:mm:ss
   414                              <1>                         ;1 = day month year hh:mm:ss
   415                              <1>                         ;2 = year month day hh:mm:ss
   416 00000002 ??????????          <1>     .curr       db 5 dup (?)   ;ASCIIZ Currency symbol (5 chars)
   417 00000007 ????                <1>     .thouSep    db 2 dup (?)   ;ASCIIZ Thousands separator
   418 00000009 ????                <1>     .dcmlSep    db 2 dup (?)   ;ASCIIZ Decimal separator
   419 0000000B ????                <1>     .dateSep    db 2 dup (?)   ;ASCIIZ Date separator
   420 0000000D ????                <1>     .timeSep    db 2 dup (?)   ;ASCIIZ Time separator
   421 0000000F ??                  <1>     .currFmt    db ?    ;Currency Format
   422                              <1>                         ;0 = Symbol leads, without space
   423                              <1>                         ;1 = Symbol follows, without space
   424                              <1>                         ;2 = Symbol leads, one space
   425                              <1>                         ;3 = Symbol follows, one space
   426                              <1>                         ;4 = Symbol replace decimal separator
   427 00000010 ??                  <1>     .digtdpt    db ?    ;Number of digits after the decimal point
   428 00000011 ??                  <1>     .timefmt    db ?    ;Time format, Bit 0 = 0 => 12 hour, = 1 => 24 hour clock
   429 00000012 ????????????????    <1>     .mapptr     db 8 dup (?)  ;Case map address (0 is nulptr), needs fixing up
   430 0000001A ????                <1>     .dataSep    db 2 dup (?)  ;Data list separator
   431 0000001C <res Ah>            <1>     .resv       db 10 dup (?) ;Reserve 10 bytes
   432                              <1> endstruc
   433                              <1> 
   434                              <1> ;Critical Error AH bitfield equates
   435                              <1> critRead    equ 0h
   436                              <1> critWrite   equ 1h
   437                              <1> critDOS     equ 0h
   438                              <1> critFAT     equ 2h
   439                              <1> critDir     equ 4h
   440                              <1> critData    equ 6h
   441                              <1> critFailOK  equ 8h
   442                              <1> critRetryOK equ 10h
   443                              <1> critIgnorOK equ 20h
   444                              <1> critCharDev equ 80h
   445                              <1> 
   446                              <1> critIgnore  equ 0
   447                              <1> critRetry   equ 1
   448                              <1> critAbort   equ 2
   449                              <1> critFail    equ 3
   450                              <1> 
   451                              <1> ;MISC ASCII control chars
   452                              <1> NUL equ 00h ;^@         | ASCII Null
   453                              <1> ETX equ 03h ;^C         | ASCII Break (End of Text) 
   454                              <1> ACK equ 06h ;^F         | ASCII Acknowledgement
   455                              <1> BEL equ 07h ;^G         | ASCII Bell
   456                              <1> BSP equ 08h ;^H         | ASCII Backspace
   457                              <1> TAB equ 09h ;^I         | ASCII Horizontal Tab
   458                              <1> LF  equ 0Ah ;^J         | ASCII Line Feed
   459                              <1> CR  equ 0Dh ;^M         | ASCII Carriage Return
   460                              <1> DLE equ 10h ;^P         | ASCII Data Link End (Toggle Print Echo)
   461                              <1> DC3 equ 13h ;^S         | ASCII Device Control 3 (Toggle Scroll Lock)
   462                              <1> DC4 equ 14h ;^T         | ASCII Device Control 4
   463                              <1> NAK equ 15h ;^U         | ASCII Negative Acknowledgement
   464                              <1> ETB equ 17h ;^W         | ASCII End of Transmission Block
   465                              <1> EOF equ 1Ah ;^Z         | ASCII Substitute character (End of File)
   466                              <1> ESC equ 1Bh ;           | ASCII Escape char, used for ANSI.SYS
   467                              <1> SPC equ 20h ;Printable  | ASCII Space
   468                              <1> ;This last one is NEVER printed with a caret as it is a console control char
   469                              <1> DEL equ 7Fh ;^?         | ASCII Rubout (Del char and dec cursor)
   470                              <1> 
   471                              <1> asciiCaret  equ 20h ;Used to check which chars need to be printed with caret
   472                              <1> ;Extended Ascii Codes
   473                              <1> eF1     equ 3Bh ;F1 second byte
   474                              <1> eF2     equ 3Ch ;F2 second byte
   475                              <1> eF3     equ 3Dh ;F3 second byte
   476                              <1> eF4     equ 3Eh ;F4 second byte
   477                              <1> eF5     equ 3Fh ;F5 second byte
   478                              <1> eF6     equ 40h ;F6 second byte
   479                              <1> eF7     equ 41h ;F7 second byte
   480                              <1> eCursL  equ 4Bh ;Cursor Left second byte
   481                              <1> eCursR  equ 4Dh ;Cursor Right second byte
   482                              <1> eIns    equ 52h ;Insert second byte
   483                              <1> eDel    equ 53h ;DEL second byte (not necessarily delete key)
   484                              <1> 
   485                              <1> ;Default Configuration for the system
   486                              <1> 
   487                              <1> buffersDefault  equ 30
   488                              <1> filesDefault    equ 20
   489                              <1> fcbsDefault     equ 4
   490                              <1> safeFcbsDeflt   equ 0
   491                              <1> lastDriveDeflt  equ 5   
   492                              <1> 
   493                              <1> ;ASCII char property table equates. If such a bit is clear in signature in table
   494                              <1> ; then the char has this property.
   495                              <1> badChar     equ 1   ;Bad ASCIIZ filename char
   496                              <1> termChar    equ 2   ;Terminator char type
   497                              <1> sepChar     equ 4   ;Separator char type
   498                              <1> badFCBChar  equ 8   ;FCB filename char
   499                              <1> 
   500                              <1> struc fatDirEntry
   501                              <1> 
   502 00000000 <res Bh>            <1>     .name       db 11 dup (?) ;8.3 File Name w/o fullstop
   503 0000000B ??                  <1>     .attribute  db ?  ;Usual attributes
   504 0000000C ??                  <1>     .ntRes      db ?  ;Reserved 0
   505 0000000D ??                  <1>     .crtTimeT   db ?  ;Count of tenths of a second of file creation time <=199
   506 0000000E ????                <1>     .crtTime    dw ?  ;Creation time, granularity of 2 seconds
   507 00000010 ????                <1>     .crtDate    dw ?  ;Creation date
   508 00000012 ????                <1>     .lastAccDat dw ?  ;Last Read/Write date, not 100% supported (consider later)
   509 00000014 ????                <1>     .fstClusHi  dw ?  ;Hi word of 1st data cluster for file/dir, 0 on FAT12/16
   510 00000016 ????                <1>     .wrtTime    dw ?  ;Last modification (write) time
   511 00000018 ????                <1>     .wrtDate    dw ?  ;Last modification (write) date
   512 0000001A ????                <1>     .fstClusLo  dw ?  ;Lo word of 1st data cluster for file/dir
   513 0000001C ????????            <1>     .fileSize   dd ?  ;32-bit quantity with size of file described by entry
   514                              <1> 
   515                              <1> endstruc
    17                                  %include "./inc/dosError.inc"
     1                              <1> ;DOS Error codes
     2                              <1> 
     3                              <1> ;Extended Error Codes
     4                              <1> errInvFnc   equ 1   ;Invalid function number
     5                              <1> errFnf      equ 2   ;File not found
     6                              <1> errPnf      equ 3   ;Path not found
     7                              <1> errNhl      equ 4   ;Too many open handles, no handles left
     8                              <1> errAccDen   equ 5   ;Access denied (to resource)
     9                              <1> errBadHdl   equ 6   ;Invalid handle
    10                              <1> errMCBbad   equ 7   ;MCB's destroyed
    11                              <1> errNoMem    equ 8   ;Insufficient memory
    12                              <1> errMemAddr  equ 9   ;Invalid Memory Block Address
    13                              <1> errBadEnv   equ 10  ;Invalid environment
    14                              <1> errBadFmt   equ 11  ;Invalid format (path etc)
    15                              <1> errAccCde   equ 12  ;Invalid Access Code    ?
    16                              <1> errInvDat   equ 13  ;Invalid data
    17                              <1> ;           equ 14  ;Reserved
    18                              <1> errBadDrv   equ 15  ;Invalid drive specified
    19                              <1> errDelCD    equ 16  ;Attempt to delete the current directory
    20                              <1> errDevUnk   equ 17  ;Not the same device (Device Unknown)
    21                              <1> errNoFil    equ 18  ;No more files, no match found
    22                              <1> ;The following are Driver error codes + 19
    23                              <1> drvErrShft  equ 19  ;Used to shift Driver error codes to extended error codes
    24                              <1> errWpd      equ 19  ;Attempt to write on write protected disk
    25                              <1> errUnkUnt   equ 20  ;Unknown Unit
    26                              <1> errDrvNR    equ 21  ;Drive not ready
    27                              <1> errUnkCmd   equ 22  ;Unknown Command
    28                              <1> errCRCerr   equ 23  ;Data (CRC) error
    29                              <1> errBadRLn   equ 24  ;Bad request structure length
    30                              <1> errSekErr   equ 25  ;Seek error
    31                              <1> errUnkMed   equ 26  ;Unknown media type
    32                              <1> errSecNF    equ 27  ;Sector not Found
    33                              <1> errNoPap    equ 28  ;Printer out of paper
    34                              <1> errWF       equ 29  ;Write fault
    35                              <1> errRF       equ 30  ;Read fault
    36                              <1> errGF       equ 31  ;General fault
    37                              <1> ;----------------------------------------------
    38                              <1> ;The following two go inbetween the Disk errors
    39                              <1> errShrVio   equ 32  ;Sharing violations
    40                              <1> errLokVio   equ 33  ;File Lock violation
    41                              <1> ;----------------------------------------------
    42                              <1> errIDC      equ 34  ;Driver code, Invalid Disk Change
    43                              <1> errNoFCB    equ 35  ;FCB unavailable
    44                              <1> errShrFul   equ 36  ;Sharing buffer full
    45                              <1> 
    46                              <1> errNoNet    equ 50  ;Network request not supported, generic net fail
    47                              <1> 
    48                              <1> errFilExist equ 80  ;File already exists
    49                              <1> errDirExist equ 82  ;Directory already exists
    50                              <1> errFI44     equ 83  ;Fail on Int 24h
    51                              <1> errRedir    equ 84  ;Too many levels of redirection
    52                              <1> errDupRedir equ 85  ;Trying to redirect a redirection
    53                              <1> errBadPass  equ 86  ;Bad password
    54                              <1> errBadParam equ 87  ;Bad parameter passed to request
    55                              <1> errNetWrite equ 88  ;Network Write Fault
    56                              <1> ;-----------------------------------------------------------------------------
    57                              <1> ;Error Loci
    58                              <1> eLocUnk     equ 1   ;Unknown locus, nonspecific or not appropriate
    59                              <1> eLocDsk     equ 2   ;Disk, related to Random Access to a disk or block device
    60                              <1> eLocNet     equ 3   ;Network related issues, shouldnt affect us (yet!)
    61                              <1> eLocChr     equ 4   ;Serial/Character Device error
    62                              <1> eLocMem     equ 5   ;Related to RAM
    63                              <1> ;-----------------------------------------------------------------------------
    64                              <1> ;Error Actions
    65                              <1> eActRet     equ 1   ;Retry
    66                              <1> eActDRet    equ 2   ;Delay then retry (Try again later)
    67                              <1> eActUsr     equ 3   ;Ask user to re-input data, i.e. bad filename or something
    68                              <1> eActAbt     equ 4   ;Abort with cleanup
    69                              <1> eActKil     equ 5   ;Abort without cleanup
    70                              <1> eActIgn     equ 6   ;Ignore error
    71                              <1> eActRetUsr  equ 7   ;Retry after user intervention (i.e swap remdev)
    72                              <1> ;-----------------------------------------------------------------------------
    73                              <1> ;Error classes
    74                              <1> eClsOoR     equ 1   ;Out of resources, no mem or handles
    75                              <1> eClsTS      equ 2   ;Temp sitch, should go away
    76                              <1> eClsAuth    equ 3   ;Authorisation, e.g. file permission error 
    77                              <1> eClsInt     equ 4   ;Internal DOS error or bug
    78                              <1> eClsHrdFlt  equ 5   ;Hardware Failure
    79                              <1> eClsSysFlt  equ 6   ;System Failure, i.e. missing or bad cfg files
    80                              <1> eClsAppFlt  equ 7   ;Application Program error, inconsistent requests etc...
    81                              <1> eClsNotFnd  equ 8   ;Resource not found (such as free SFT entry etc...)
    82                              <1> eClsBadFmt  equ 9   ;Bad format for resource
    83                              <1> eClsLocked  equ 10  ;Resource Locked
    84                              <1> eClsMedia   equ 11  ;Error is on medium, i.e. wrong or damaged remdev
    85                              <1> eClsClash   equ 12  ;Resource already exists!
    86                              <1> eClsUnk     equ 13  ;Unknown class
    18                                  %include "./inc/dosVars.inc"
     1                              <1> struc sysVars
     2 00000000 ????????????????    <1>     .dpbHeadPtr  dq ?    ;Pointer to the first DPB in the DPB chain x
     3 00000008 ????????????????    <1>     .sftHeadPtr  dq ?    ;Pointer to the first SFT header in SFT chain
     4 00000010 ????????????????    <1>     .clockPtr    dq ?    ;Pointer to the current active CLOCK$ device header x
     5                              <1>     ;                    The last driver loaded with the CLOCK$ bit[3] set 
     6 00000018 ????????????????    <1>     .vConPtr     dq ?    ;Ptr to the devdrv of the char dev controlling vCon x
     7                              <1>     ;                    The last driver loaded with the STDIN bit[0] set
     8 00000020 ????                <1>     .maxBytesSec dw ?    ;Maximum number of bytes per sector (size of buffers)x
     9 00000022 ????????????????    <1>     .bufHeadPtr  dq ?    ;Pointer to the head of the disk buffer chain x
    10 0000002A ????????????????    <1>     .cdsHeadPtr  dq ?    ;Pointer to the head of the CDS array x
    11 00000032 ????????????????    <1>     .fcbsHeadPtr dq ?    ;Pointer to the head of the System FCB chain
    12 0000003A ????                <1>     .numSafeSFCB dw ?    ;Number of protected FCBs (y in FCBS=x,y)
    13 0000003C ??                  <1>     .numPhysVol  db ?    ;Number of physical volumes in the system x
    14 0000003D ??                  <1>     .lastdrvNum  db ?    ;Value of LASTDRIVE (default = 5) [Size of CDS array]x
    15 0000003E ??                  <1>     .numBuffers  db ?    ;Buffers=30 default
    16 0000003F <res 22h>           <1>     .nulDevHdr   db 22h dup (?)
    17 00000061 ??                  <1>     .numJoinDrv  db ?    ;Number of Joined Drives
    18                              <1> endstruc
    19                              <1> 
    20                              <1> ioReqPkt_size equ 2Ah
    21                              <1> 
    22                              <1> struc sda
    23 00000000 ??                  <1>     .critErrFlag db ?  ;Critical error flag, set on entry to Int 24h x
    24 00000001 ??                  <1>     .inDOS       db ?  ;Inc on each DOS call, dec when leaving x
    25 00000002 ??                  <1>     .errorDrv    db ?  ;Drive on which error occured or FFh x
    26 00000003 ??                  <1>     .errorLocus  db ?  ;Where the error took place  
    27 00000004 ????                <1>     .errorExCde  dw ?  ;Extended Error Code
    28 00000006 ??                  <1>     .errorAction db ?  ;Suggested action for error  
    29 00000007 ??                  <1>     .errorClass  db ?  ;Error Class
    30 00000008 ????????????????    <1>     .errorVolLbl dq ?    ;Sets a ptr to the volume label of the error disk
    31 00000010 ????????????????    <1>     .currentDTA  dq ?  ;Address of the current DTA x
    32 00000018 ????????????????    <1>     .currentPSP  dq ?  ;Address of current PSP x
    33 00000020 ????????????????    <1>     .xInt23hRSP  dq ?  ;Saves RSP across an Int 23h call
    34 00000028 ????                <1>     .errorLevel  dw ?  ;Last return code returned by Int 21h/4Ch x
    35 0000002A ??                  <1>     .currentDrv  db ?  ;Default drive x
    36 0000002B ??                  <1>     .breakFlag   db ?  ;If set, check for CTRL+C on all DOS calls x
    37 0000002C ????????????????    <1>     .oldRAX      dq ?  ;Store rax on entering Int21h or returning Int 23h
    38 00000034 ????????????????    <1>     .serverPSP   dq ?  ;PSP of prog making server request, used by net & share
    39 0000003C ????                <1>     .machineNum  dw ?  ;for sharing/networking 00h = default number (us)
    40 0000003E ????????????????    <1>     .firstMCB    dq ?  ;First fit MCB for request
    41 00000046 ????????????????    <1>     .bestMCB     dq ?  ;Best fit MCB for request
    42 0000004E ????????????????    <1>     .lastMCB     dq ?  ;Last fit MCB for request
    43 00000056 ????                <1>     .dirEntryNum dw ?  ;Offset into directory of entry we are looking for
    44 00000058 ??                  <1>     .volIdFlag   db ?    ;If set, we are searching for a volume ID
    45 00000059 ????????????????    <1>     .xInt24hRSP  dq ?  ;RSP across an Int 24h call
    46 00000061 ??                  <1>     .Int24bitfld db ?  ;Copies the bit field given to the Int 24h handler
    47 00000062 ??                  <1>     .fileDirFlag db ?  ;File/Directory flag. 0 = Dir, 0 = File
    48 00000063 ??                  <1>     .Int24Fail   db ?  ;Set if Int 24h returned fail
    49 00000064 ????????????????    <1>     .oldoldRSP   dq ?  ;RSP at prev Int 21h entry if called from within Int 21h
    50 0000006C ????????????????    <1>     .dosReturn   dq ?  ;Used as a var to return when juggling stack
    51 00000074 ????????????????    <1>     .oldRSP      dq ?  ;RSP when entering Int 21h
    52 0000007C ????????????????    <1>     .oldRBX      dq ?  ;Temp var to save value of rbx during an Int 21 call
    53 00000084 ??                  <1>     .dirFlag     db ?  ;Directory Flag. 0 => Search for Dir, 1 => for File
    54 00000085 ??                  <1>     .ctrlCExit   db ?  ;-1 => CTRL+BREAK termination, 0 otherwise
    55 00000086 ??                  <1>     .fcbSpaceOk  db ?  ;If set, we allow embedded spaces in the filenames
    56 00000087 ??                  <1>     .dayOfMonth  db ?  ;01h - 1Fh (1 - 31)
    57 00000088 ??                  <1>     .monthOfYear db ?  ;01h - 0Ch (1 - 12)
    58 00000089 ??                  <1>     .years       db ?  ;00h - 7Fh (00 = 1980 - 127 = 2107)
    59 0000008A ????                <1>     .daysOffset  dw ?  ;Days since 1-1-1980
    60 0000008C ??                  <1>     .dayOfWeek   db ?  ;0 = Sunday <-> 6 = Saturday
    61 0000008D ??                  <1>     .vConDrvSwp  db ?  ;Set if vCon controlled by a different driver to vConPtr
    62 0000008E ??                  <1>     .int28Flag   db ?  ;If set, Int 28h should be called, if clear no
    63 0000008F ??                  <1>     .Int24Trans  db ?  ;Set to -1 if Abort translated to Fail
    64 00000090 <res 2Ah>           <1>     .secdReqPkt  db ioReqPkt_size dup (?) ;Secondary, Char IO Reqhdr
    65 000000BA <res 2Ah>           <1>     .primReqPkt  db ioReqPkt_size dup (?) ;Main Drv Reqhdr 
    66 000000E4 <res 2Ah>           <1>     .critReqPkt  db ioReqPkt_size dup (?)  ;Used for ^C detection!
    67 0000010E ??                  <1>     .pspCopyFlg  db ?  ;Set to -1 for child process PSP, 0 for simple PSP copy
    68 0000010F ????????????        <1>     .CLOCKrecrd  db 6 dup (?)  ;Clock driver record
    69 00000115 ????                <1>     .singleIObyt dw ?  ;For single IO byte buffers
    70 00000117 <res 80h>           <1>     .buffer1     db 128 dup (?)  ;Space for one path and file name
    71 00000197 <res 80h>           <1>     .buffer2     db 128 dup (?) ;Space for a second path and file name
    72 00000217 ????????????????    <1>     .fname1Ptr   dq ?  ;Ptr to first filename argument
    73 0000021F ????????????????    <1>     .fname2Ptr   dq ?  ;Ptr to second filename argument
    74 00000227 ??                  <1>     .skipDisk    db ?  ;Set => Read Disk, Clear => Skip checking on disk
    75 00000228 <res 2Bh>           <1>     .dosffblock  db ffBlock_size dup (?)  ;FF block (fullsize unlike DOS)
    76 00000253 <res 20h>           <1>     .curDirCopy  db fatDirEntry_size dup (?)  ;Dir copy
    77                              <1> endstruc
    19                                  %include "./src/main.asm"
     1                              <1> ;Join main routine
     2                              <1> startMain:
     3 00000000 EB01                <1>     jmp short .cVersion
     4 00000002 01                  <1> .vNum:  db 1
     5                              <1> .cVersion:
     6 00000003 488D25(2B020000)    <1>     lea rsp, endOfAlloc   ;Move RSP to our internal stack
     7                              <1> ;Do a version check since this version cannot check the number of rows/cols
     8 0000000A FC                  <1>     cld
     9 0000000B B800300000          <1>     mov eax, 3000h
    10 00000010 CD21                <1>     int 21h
    11 00000012 3A05EAFFFFFF        <1>     cmp al, byte [.vNum]    ;Version number 1 check
    12 00000018 762B                <1>     jbe short okVersion
    13 0000001A 488D15F2040000      <1>     lea rdx, badVerStr
    14                              <1> badPrintExit:
    15 00000021 B800090000          <1>     mov eax, 0900h
    16 00000026 CD21                <1>     int 21h
    17 00000028 B8FF4C0000          <1>     mov eax, 4CFFh
    18 0000002D CD21                <1>     int 21h
    19                              <1> testMplx:
    20                              <1> ;Tests if either sesman or multi are installed.
    21                              <1> ;Output: ZF=NZ: Either installed.
    22                              <1> ;        ZF=ZY: Neither installed, proceed!
    23 0000002F B800090000          <1>     mov eax, 0900h
    24 00000034 CD2F                <1>     int 2Fh
    25 00000036 A8FF                <1>     test al, -1
    26                              <1>     retnz
    45                              <2> cret nz
    19                              <3> %%_base:
    20                              <3> %assign baseVar %%_base-$$
    21                              <3>  %ifdef retOff
    22                              <3>  %if (baseVar - retOff <= 126) && (baseVar > retOff)
    23                              <3>  %ifdef currSegVBase
    24                              <3>  j%+1 short (retOff+currSegVBase)
    25                              <3>  %else
    26                              <3>  j%+1 short retOff
    27                              <3>  %endif
    28                              <3>  %else
    29                              <3>  j%-1 short %%a
    30                              <3>  return
    31                              <3> %%a:
    32                              <3>  %endif
    33                              <3>  %else
    34 00000038 7401                <3>  j%-1 short %%a
    35                              <3>  return
    13                              <4> %%_ret:
    14 0000003A C3                  <4>  ret
    15                              <4> %assign retOff %%_ret-$$
    36                              <3> %%a:
    37                              <3>  %endif
    27 0000003B B8000A0000          <1>     mov eax, 0A00h
    28 00000040 CD2F                <1>     int 2Fh
    29 00000042 A8FF                <1>     test al, -1
    30                              <1>     return
    13                              <2> %%_ret:
    14 00000044 C3                  <2>  ret
    15                              <2> %assign retOff %%_ret-$$
    31                              <1> okVersion:
    32                              <1> ;In later versions of JOIN, we use the CDS ptr of the parent
    33                              <1> ; process. For now, we just exit error if we enter with either
    34                              <1> ; sesman or multi installed.
    35 00000045 E8E5FFFFFF          <1>     call testMplx
    36 0000004A 7409                <1>     jz clearBss
    37 0000004C 488D153B050000      <1>     lea rdx, badMultStr
    38 00000053 EBCC                <1>     jmp short badPrintExit
    39                              <1> clearBss:
    40                              <1> ;Now we init the BSS to 0.
    41 00000055 488D3D(00000000)    <1>     lea rdi, bssStart
    42 0000005C 31C0                <1>     xor eax, eax
    43 0000005E B9C3000000          <1>     mov ecx, bssLen
    44 00000063 F3AA                <1>     rep stosb
    45                              <1> ;Now let us resize ourselves so as to take up as little memory as possible
    46 00000065 488D1D(2B020000)    <1>     lea rbx, endOfAlloc ;Number of bytes of the allocation
    47 0000006C 4C29C3              <1>     sub rbx, r8
    48 0000006F 81C30F000000        <1>     add ebx, 0Fh        ;Round up
    49 00000075 C1EB04              <1>     shr ebx, 4          ;Turn into number of paragraphs
    50 00000078 B8004A0000          <1>     mov eax, 4A00h
    51 0000007D CD21                <1>     int 21h ;If this fails, we still proceed as we are just being polite!
    52                              <1> ;Now get the sysvars pointer and save it in var.
    53                              <1> ;This cannot change so it is fine to do it out of a critical section.
    54 0000007F B800520000          <1>     mov eax, 5200h
    55 00000084 CD21                <1>     int 21h
    56 00000086 48891D(00000000)    <1>     mov qword [pSysvars], rbx
    57                              <1> parseCmdLine:
    58                              <1> ;Now parse the command line
    59 0000008D 498DB081000000      <1>     lea rsi, qword [r8 + psp.progTail]
    60 00000094 31C9                <1>     xor ecx, ecx    ;Keep a count of vars on cmd line in ecx
    61 00000096 E82B040000          <1>     call skipDelims ;Goto the first non-delimiter char
    62 0000009B 3C0D                <1>     cmp al, CR
    63 0000009D 7441                <1>     je endParse
    64 0000009F 488935(08000000)    <1>     mov qword [pVar1], rsi    ;Save the ptr to the first var
    65 000000A6 FFC1                <1>     inc ecx
    66 000000A8 E825040000          <1>     call findDelimOrCR
    67 000000AD 3C0D                <1>     cmp al, CR
    68 000000AF 742F                <1>     je endParse
    69 000000B1 E810040000          <1>     call skipDelims
    70 000000B6 488935(10000000)    <1>     mov qword [pVar2], rsi    ;Save the ptr to the second var
    71 000000BD FFC1                <1>     inc ecx
    72 000000BF E80E040000          <1>     call findDelimOrCR
    73 000000C4 3C0D                <1>     cmp al, CR  ;The second arg shouldve been the last arg
    74 000000C6 7418                <1>     je endParse
    75                              <1> badPrmsExit:
    76                              <1> ;Too many parameters and/or badly formatted cmdline error
    77 000000C8 488D155C040000      <1>     lea rdx, badPrmsStr
    78 000000CF E94DFFFFFF          <1>     jmp badPrintExit
    79                              <1> badParmExit:
    80                              <1> ;Bad but valid parameter passed in
    81 000000D4 488D1571040000      <1>     lea rdx, badParmStr
    82 000000DB E941FFFFFF          <1>     jmp badPrintExit
    83                              <1> endParse:
    84 000000E0 85C9                <1>     test ecx, ecx
    85 000000E2 0F8455030000        <1>     jz printJoin   ;If no arguments found, print the joins!
    86 000000E8 81F901000000        <1>     cmp ecx, 1      
    87 000000EE 74D8                <1>     je badPrmsExit  ;Cannot have just 1 argument on the cmdline
    88 000000F0 B800370000          <1>     mov eax, 3700h  ;Get switchchar in dl
    89 000000F5 CD21                <1>     int 21h
    90 000000F7 31C9                <1>     xor ecx, ecx    ;Use as cntr (1 or 2) to indicate which var has ptr to /D
    91 000000F9 488B35(08000000)    <1>     mov rsi, qword [pVar1]
    92 00000100 3816                <1>     cmp byte [rsi], dl
    93 00000102 7509                <1>     jne .g2
    94 00000104 E89C030000          <1>     call checkSwitchOk  ;Now check rsi points to a bona fide /D 
    95 00000109 72BD                <1>     jc badPrmsExit
    96 0000010B FFC1                <1>     inc ecx
    97                              <1> .g2:
    98 0000010D 488B35(10000000)    <1>     mov rsi, qword [pVar2]
    99 00000114 3816                <1>     cmp byte [rsi], dl
   100 00000116 7510                <1>     jne .switchDone
   101 00000118 85C9                <1>     test ecx, ecx   ;Var2 can be /D ONLY IF Var1 was not /D
   102 0000011A 75AC                <1>     jnz badPrmsExit
   103 0000011C E884030000          <1>     call checkSwitchOk  ;Now check rsi points to a bona fide /D 
   104 00000121 72A5                <1>     jc badPrmsExit
   105 00000123 B902000000          <1>     mov ecx, 2      ;Else, indicate var2 has the /D flag!
   106                              <1> .switchDone:
   107 00000128 85C9                <1>     test ecx, ecx   ;If ecx is zero, then we are creating a join.
   108 0000012A 0F84B3000000        <1>     jz addJoin
   109                              <1> ;Else we are deleting a join drive.
   110                              <1> delJoin:
   111 00000130 488B35(08000000)    <1>     mov rsi, qword [pVar1]
   112 00000137 488B3D(10000000)    <1>     mov rdi, qword [pVar2]
   113 0000013E 81F901000000        <1>     cmp ecx, 1          ;If ecx = 1, rsi points to the /D
   114 00000144 480F45FE            <1>     cmovne rdi, rsi     ;Make rdi point to the drive letter!
   115                              <1> ;rdi points to the drive letter in cmdline. Check it is legit.
   116 00000148 8A4702              <1>     mov al, byte [rdi + 2]
   117 0000014B E88E030000          <1>     call isALDelimOrCR  ;Ensure the string length is 2!
   118 00000150 0F8572FFFFFF        <1>     jne badPrmsExit
   119 00000156 807F013A            <1>     cmp byte [rdi + 1], ":"
   120 0000015A 0F8568FFFFFF        <1>     jne badPrmsExit
   121                              <1> ;Here the char is legit! Now UC it and use it as offset into CDS
   122                              <1> ; to deactivate it!
   123 00000160 0FB607              <1>     movzx eax, byte [rdi]
   124 00000163 50                  <1>     push rax
   125 00000164 B813120000          <1>     mov eax, 1213h  ;UC char
   126 00000169 CD2F                <1>     int 2Fh
   127 0000016B 0FB6C8              <1>     movzx ecx, al   ;Move the UC char into ecx
   128 0000016E 58                  <1>     pop rax         ;Rebalance the stack
   129 0000016F 81E941000000        <1>     sub ecx, "A"    ;Turn into an offset into CDS
   130                              <1> ;Check if we are deleting the current drive.
   131 00000175 B800190000          <1>     mov eax, 1900h  ;Get current drive
   132 0000017A CD21                <1>     int 21h
   133 0000017C 38C8                <1>     cmp al, cl  ;If we are deleting the current drive, error exit!
   134 0000017E 0F8450FFFFFF        <1>     je badParmExit
   135                              <1> ;Check if the join drive we want to deactivate is a valid drive
   136                              <1> ; in our system (i.e. does such a drive entry exist in the CDS array)
   137                              <1>     ;call enterDOSCrit   ;Enter crit, Exit in the exit routine!
   138 00000184 488B1D(00000000)    <1>     mov rbx, qword [pSysvars]   
   139                              <1> ;If drive specified to remove is past end of CDS array, error!
   140 0000018B 384B3D              <1>     cmp byte [rbx + sysVars.lastdrvNum], cl
   141 0000018E 764E                <1>     jbe .error
   142                              <1> ;Point rdi to the cds we are adjusting.
   143 00000190 488B7B2A            <1>     mov rdi, qword [rbx + sysVars.cdsHeadPtr]   ;Point rdi to cds array
   144 00000194 B85F000000          <1>     mov eax, cds_size
   145 00000199 F7E1                <1>     mul ecx
   146 0000019B 81C141000000        <1>     add ecx, "A"    ;Turn offset back into a UC drive letter!
   147 000001A1 4801C7              <1>     add rdi, rax    ;rdi now points to the right CDS
   148                              <1> ;Check the cds we have chosen is really a join drive
   149 000001A4 66F747430020        <1>     test word [rdi + cds.wFlags], cdsJoinDrive
   150 000001AA 7432                <1>     jz .error      ;If this CDS is not a join drive, error!
   151                              <1> ;Start editing the CDS back to it's default state
   152 000001AC 880F                <1>     mov byte [rdi], cl  ;Place the drive letter...
   153 000001AE 66C747025C00        <1>     mov word [rdi + 2], "\"   ;... and root backslash with null terminator!
   154 000001B4 C6475D02            <1>     mov byte [rdi + cds.wBackslashOffset], 2    ;Go to root!
   155 000001B8 C7474D00000000      <1>     mov dword [rdi + cds.dStartCluster], 0      ;Set start cluster for root!
   156                              <1> ;Deactivate the join!
   157 000001BF 66816743FFDF        <1>     and word [rdi + cds.wFlags], ~cdsJoinDrive 
   158 000001C5 488B1D(00000000)    <1>     mov rbx, qword [pSysvars]
   159 000001CC 807B6100            <1>     cmp byte [rbx + sysVars.numJoinDrv], 0  ;Should never happen!
   160 000001D0 0F84C8020000        <1>     je exit
   161 000001D6 FE4B61              <1>     dec byte [rbx + sysVars.numJoinDrv]
   162 000001D9 E9C0020000          <1>     jmp exit
   163                              <1> .error:
   164                              <1> ;Invalid drive specified!
   165                              <1>     ;call exitDOSCrit    ;Exit the critical section before exiting!!
   166 000001DE E9F1FEFFFF          <1>     jmp badParmExit
   167                              <1>     
   168                              <1> addJoin:
   169                              <1> ;Here we add the join path. We gotta check that path provided
   170                              <1> ; exists! It is not null terminated so we gotta null terminate it.
   171                              <1> ; We also gotta get rid of any trailing slashes from the path provided!
   172                              <1> ;
   173                              <1> ;Drive1 can be valid, be cannot be a subst, join or net drive!
   174                              <1> ;
   175 000001E3 488B35(08000000)    <1>     mov rsi, qword [pVar1]
   176 000001EA E8E3020000          <1>     call findDelimOrCR
   177 000001EF C60600              <1>     mov byte [rsi], 0   ;Null terminate var1
   178 000001F2 488B35(10000000)    <1>     mov rsi, qword [pVar2]
   179 000001F9 E8D4020000          <1>     call findDelimOrCR
   180 000001FE C60600              <1>     mov byte [rsi], 0   ;Null terminate var2
   181                              <1> 
   182 00000201 31ED                <1>     xor ebp, ebp        ;Use rbp as the ptr to the drive spec string
   183                              <1> 
   184 00000203 488B35(08000000)    <1>     mov rsi, qword [pVar1]  ;Check if var1 is drive specification
   185 0000020A 66817E013A00        <1>     cmp word [rsi + 1], ":" ;Is pVar1 a drive specification?
   186 00000210 480F44EE            <1>     cmove rbp, rsi  ;Move the ptr to the drive specifier into rbp
   187                              <1> 
   188 00000214 488B35(10000000)    <1>     mov rsi, qword [pVar2]  ;Check if var2 is drive specification
   189 0000021B 66817E013A00        <1>     cmp word [rsi + 1], ":" ;Is pVar2 a drive specification?
   190 00000221 750C                <1>     jne .gotDrvSpec
   191 00000223 4885ED              <1>     test rbp, rbp   ;rbp must be null, else two drives were specified. Error!
   192 00000226 0F85A8FEFFFF        <1>     jnz badParmExit ;Cmdline valid but invalid data passed!
   193 0000022C 4889F5              <1>     mov rbp, rsi    ;Set rbp to point to the drive
   194                              <1> .gotDrvSpec:
   195                              <1> ;Come here with rbp pointing to the new join drive spec. 
   196 0000022F 0FB64500            <1>     movzx eax, byte [rbp]
   197 00000233 50                  <1>     push rax
   198 00000234 B813120000          <1>     mov eax, 1213h  ;UC the char in al
   199 00000239 CD2F                <1>     int 2Fh
   200 0000023B 2C41                <1>     sub al, "A"     ;Turn into a 0 based drive number
   201 0000023D 8805(19000000)      <1>     mov byte [joinDrv], al
   202 00000243 58                  <1>     pop rax
   203                              <1> ;Make rsi point to the other argument!
   204 00000244 488B35(08000000)    <1>     mov rsi, qword [pVar1]
   205 0000024B 488B3D(10000000)    <1>     mov rdi, qword [pVar2]
   206 00000252 4839F5              <1>     cmp rbp, rsi  ;if rbp -> var1...  
   207 00000255 480F44F7            <1>     cmove rsi, rdi  ;... make rsi -> var2. Else, rsi -> var1
   208                              <1> ;rsi -> ASCIIZ path. Must check it is a legit path.
   209 00000259 488D3D(1A000000)    <1>     lea rdi, qword [inCDS + cds.sCurrentPath]
   210 00000260 B81A120000          <1>     mov eax, 121Ah
   211 00000265 CD2F                <1>     int 2Fh
   212 00000267 0F8267FEFFFF        <1>     jc badParmExit  ;Bad drive selected if CF=CY
   213 0000026D 84C0                <1>     test al, al
   214 0000026F 7509                <1>     jnz .notDefault
   215 00000271 B800190000          <1>     mov eax, 1900h
   216 00000276 CD21                <1>     int 21h
   217 00000278 FFC0                <1>     inc eax
   218                              <1> .notDefault:
   219 0000027A 89C2                <1>     mov edx, eax    ;Save 1 based drive number in dl
   220 0000027C FFC8                <1>     dec eax         ;Convert the drive number to 0 based
   221 0000027E 3A05(19000000)      <1>     cmp al, byte [joinDrv]  ;Check drive numbers are not equal 
   222 00000284 0F844AFEFFFF        <1>     je badParmExit
   223 0000028A 8805(18000000)      <1>     mov byte [mntDrv], al   ;Save the drive letter in the var 
   224 00000290 0441                <1>     add al, "A"
   225 00000292 B43A                <1>     mov ah, ":"
   226 00000294 66AB                <1>     stosw   ;Store drive letter 
   227 00000296 31C0                <1>     xor eax, eax
   228 00000298 AC                  <1>     lodsb   ;Get the first char of the path now and adv char ptr
   229 00000299 3C5C                <1>     cmp al, "\"
   230 0000029B 742A                <1>     je .pathSepFnd
   231 0000029D 3C2F                <1>     cmp al, "/"
   232 0000029F B05C                <1>     mov al, "\"     ;No pathsep (relpath) or unix pathsep given
   233 000002A1 7424                <1>     je .pathSepFnd
   234 000002A3 48FFCE              <1>     dec rsi         ;Return the source ptr to the first char again!
   235 000002A6 AA                  <1>     stosb           ;Store the pathsep and adv rdi
   236 000002A7 56                  <1>     push rsi        ;Save the source pointer
   237 000002A8 4889FE              <1>     mov rsi, rdi    ;Store the rest of the path here
   238 000002AB B800470000          <1>     mov eax, 4700h  ;Get the Current Directory for current drive
   239 000002B0 CD21                <1>     int 21h
   240 000002B2 5E                  <1>     pop rsi         ;Get back the pointer to the source in rsi
   241 000002B3 31C0                <1>     xor eax, eax
   242 000002B5 B9FFFFFFFF          <1>     mov ecx, -1
   243 000002BA F2AE                <1>     repne scasb     ;Move rdi past the terminating null
   244 000002BC 48FFCF              <1>     dec rdi         ;And point back to it
   245 000002BF 807FFF5C            <1>     cmp byte [rdi - 1], "\" ;Skip adding extra pathsep if one present (rt only)
   246 000002C3 7403                <1>     je .cplp
   247 000002C5 B05C                <1>     mov al, "\"
   248                              <1> .pathSepFnd:
   249 000002C7 AA                  <1>     stosb           ;Store the normalised pathsep
   250                              <1> ;Now copy the path specified by rsi to rdi. rsi is null terminated string
   251                              <1> .cplp:
   252 000002C8 AC                  <1>     lodsb
   253 000002C9 AA                  <1>     stosb
   254 000002CA 84C0                <1>     test al, al
   255 000002CC 75FA                <1>     jnz .cplp
   256                              <1> ;Now we normalise the CDS string and check it is of len leq 67
   257 000002CE 488D35(1A000000)    <1>     lea rsi, inCDS
   258 000002D5 4889F7              <1>     mov rdi, rsi
   259 000002D8 B811120000          <1>     mov eax, 1211h  ;Normalise string (UC and swap slashes.)
   260 000002DD CD2F                <1>     int 2Fh
   261 000002DF B812120000          <1>     mov eax, 1212h  ;Strlen (including terminating null)
   262 000002E4 CD2F                <1>     int 2Fh
   263 000002E6 81F943000000        <1>     cmp ecx, 67
   264 000002EC 0F87E2FDFFFF        <1>     ja badParmExit
   265 000002F2 880D(C2000000)      <1>     mov byte [mntLen], cl
   266                              <1> ;Now the CDS string is setup, check it is one path componant only.
   267                              <1> ;Also verify that there are no wildcards present in path. If so, 
   268                              <1> ; bad parameter error!
   269                              <1> .pathCheck:
   270 000002F8 31C9                <1>     xor ecx, ecx
   271                              <1> .pcLp:
   272 000002FA AC                  <1>     lodsb
   273 000002FB 84C0                <1>     test al, al
   274 000002FD 7418                <1>     jz .pcEnd
   275 000002FF 3C2A                <1>     cmp al, "*"
   276 00000301 0F84CDFDFFFF        <1>     je badParmExit
   277 00000307 3C3F                <1>     cmp al, "?"
   278 00000309 0F84C5FDFFFF        <1>     je badParmExit
   279 0000030F 3C5C                <1>     cmp al, "\"
   280 00000311 75E7                <1>     jne .pcLp
   281 00000313 FFC1                <1>     inc ecx     ;Inc pathsep counter
   282 00000315 EBE3                <1>     jmp short .pcLp
   283                              <1> .pcEnd:
   284 00000317 81F901000000        <1>     cmp ecx, 1  ;One pathsep allowed only!
   285 0000031D 0F85B1FDFFFF        <1>     jne badParmExit
   286 00000323 488D15(1A000000)    <1>     lea rdx, qword [inCDS + cds.sCurrentPath]
   287 0000032A 8B02                <1>     mov eax, dword [rdx]
   288 0000032C C1E808              <1>     shr eax, 8  ;Drop the drive letter
   289 0000032F 3D3A5C0000          <1>     cmp eax, ":\"
   290 00000334 0F849AFDFFFF        <1>     je badParmExit  ;Cannot join to root drive
   291                              <1> ;We now enter the critical section and 
   292                              <1> ; find the mount path
   293                              <1>     ;call enterDOSCrit   ;Now enter DOS critical section
   294 0000033A B8004E0000          <1>     mov eax, 4E00h  ;Find first on path pointed to by rdx
   295 0000033F B910000000          <1>     mov ecx, 10h    ;Find subdirs
   296 00000344 CD21                <1>     int 21h
   297 00000346 7315                <1>     jnc .dirFnd
   298 00000348 B800390000          <1>     mov eax, 3900h  ;MKDIR for the name pointed to by rdx
   299 0000034D CD21                <1>     int 21h
   300 0000034F 7316                <1>     jnc .dirMade
   301                              <1> .badMntpntExit:
   302 00000351 488D15F4010000      <1>     lea rdx, badParmStr
   303                              <1>     ;call exitDOSCrit
   304 00000358 E9C4FCFFFF          <1>     jmp badPrintExit
   305                              <1> .dirFnd:
   306                              <1> ;Check what we found is a subdir
   307 0000035D 4180B89500000010    <1>     cmp byte [r8 + 80h + ffBlock.attribFnd], 10h
   308 00000365 75EA                <1>     jne .badMntpntExit
   309                              <1> .dirMade:
   310                              <1> ;Now we check the mount point is empty
   311 00000367 488D3D(9A000000)    <1>     lea rdi, srchBuf
   312 0000036E 488D35(1A000000)    <1>     lea rsi, qword [inCDS + cds.sCurrentPath]
   313 00000375 0FB60D(C2000000)    <1>     movzx ecx, byte [mntLen]
   314 0000037C F3A4                <1>     rep movsb   ;Copy it over
   315 0000037E 48FFCF              <1>     dec rdi
   316 00000381 B05C                <1>     mov al, "\"
   317 00000383 AA                  <1>     stosb
   318 00000384 B82A2E2A00          <1>     mov eax, "*.*"
   319 00000389 AB                  <1>     stosd
   320                              <1>     
   321 0000038A 488D15(9A000000)    <1>     lea rdx, srchBuf
   322 00000391 B8004E0000          <1>     mov eax, 4E00h
   323 00000396 B916000000          <1>     mov ecx, 16h    ;Inclusive directory search (find ., always exists)
   324 0000039B CD21                <1>     int 21h
   325 0000039D B8004F0000          <1>     mov eax, 4F00h  ;Find .., always exists
   326 000003A2 CD21                <1>     int 21h
   327 000003A4 B8004F0000          <1>     mov eax, 4F00h  ;Try find a third file
   328 000003A9 CD21                <1>     int 21h
   329 000003AB 720C                <1>     jc .emptyDir    ;If no file found, proceed happily
   330                              <1>     ;call exitDOSCrit
   331 000003AD 488D15BD010000      <1>     lea rdx, badDirStr  ;Else, directory not empty!
   332 000003B4 E968FCFFFF          <1>     jmp badPrintExit
   333                              <1> .emptyDir:
   334                              <1> ;Check the join drive is not past lastdrv
   335 000003B9 488B1D(00000000)    <1>     mov rbx, qword [pSysvars]
   336 000003C0 0FB60D(19000000)    <1>     movzx ecx, byte [joinDrv]
   337 000003C7 384B3D              <1>     cmp byte [rbx + sysVars.lastdrvNum], cl
   338 000003CA 7705                <1>     ja .destNumOk ;Has to be above zero as cl is 0 based :)
   339                              <1> .badNumExit:
   340                              <1>     ;call exitDOSCrit
   341 000003CC E903FDFFFF          <1>     jmp badParmExit
   342                              <1> .destNumOk:
   343 000003D1 0FB60D(18000000)    <1>     movzx ecx, byte [mntDrv]    
   344 000003D8 384B3D              <1>     cmp byte [rbx + sysVars.lastdrvNum], cl
   345 000003DB 76EF                <1>     jbe .badNumExit
   346                              <1>     ;Check the mount drive is not a redir etc.
   347 000003DD E84C000000          <1>     call .getCds    ;Get mount drive cds in rdi
   348 000003E2 66F7474300B0        <1>     test word [rdi + cds.wFlags], cdsJoinDrive | cdsSubstDrive | cdsRedirDrive
   349 000003E8 740C                <1>     jz .mntOk
   350                              <1> .inDOSBadNetExit:
   351 000003EA 488D1504010000      <1>     lea rdx, badNetStr
   352                              <1>     ;call exitDOSCrit
   353 000003F1 E92BFCFFFF          <1>     jmp badPrintExit
   354                              <1> .mntOk:
   355                              <1>     ;Now we check the join drive too.
   356 000003F6 0FB60D(19000000)    <1>     movzx ecx, byte [joinDrv]
   357 000003FD E82C000000          <1>     call .getCds    ;Get the CDS ptr for the destination in rdi
   358 00000402 66F7474300B0        <1>     test word [rdi + cds.wFlags], cdsJoinDrive | cdsSubstDrive | cdsRedirDrive
   359 00000408 75E0                <1>     jnz .inDOSBadNetExit   
   360                              <1>     ;Now we modify the join drive
   361 0000040A 66814F430020        <1>     or word [rdi + cds.wFlags], cdsJoinDrive
   362 00000410 488D35(1A000000)    <1>     lea rsi, qword [inCDS + cds.sCurrentPath]
   363 00000417 0FB60D(C2000000)    <1>     movzx ecx, byte [mntLen]
   364 0000041E F3A4                <1>     rep movsb
   365                              <1> ;This should never happen, should throw error instead
   366 00000420 807B61FF            <1>     cmp byte [rbx + sysVars.numJoinDrv], 0FFh   
   367 00000424 7478                <1>     je exit
   368 00000426 FE4361              <1>     inc byte [rbx + sysVars.numJoinDrv]
   369 00000429 E970000000          <1>     jmp exit
   370                              <1> .getCds:
   371                              <1> ;Input: ecx = [byte] 0-based drive number
   372                              <1> ;       rbx -> sysVars
   373                              <1> ;Output: rdi -> CDS for drive
   374 0000042E 488B7B2A            <1>     mov rdi, qword [rbx + sysVars.cdsHeadPtr]   ;Point rdi to cds array
   375 00000432 B85F000000          <1>     mov eax, cds_size
   376 00000437 F7E1                <1>     mul ecx
   377 00000439 4801C7              <1>     add rdi, rax    ;rdi now points to the right CDS
   378                              <1>     return
    13                              <2> %%_ret:
    14 0000043C C3                  <2>  ret
    15                              <2> %assign retOff %%_ret-$$
   379                              <1> 
   380                              <1> 
   381                              <1> printJoin:
   382                              <1>     ;call enterDOSCrit   ;Ensure the CDS size and ptr doesnt change
   383 0000043D 488B1D(00000000)    <1>     mov rbx, qword [pSysvars]
   384 00000444 488B7B2A            <1>     mov rdi, qword [rbx + sysVars.cdsHeadPtr]
   385 00000448 0FB64B3D            <1>     movzx ecx, byte [rbx + sysVars.lastdrvNum]  ;Get # of CDS's
   386 0000044C BB41000000          <1>     mov ebx, "A"    
   387                              <1> .lp:
   388 00000451 66F747430020        <1>     test word [rdi + cds.wFlags], cdsJoinDrive
   389 00000457 7438                <1>     jz .gotoNextCDS
   390                              <1> ;Print the CDS drive letter and the rocket
   391 00000459 488D1527010000      <1>     lea rdx, rocketStr
   392 00000460 881A                <1>     mov byte [rdx], bl  ;Overwrite the drive letter in rocketStr
   393 00000462 B800090000          <1>     mov eax, 0900h      ;Print the rocketStr
   394 00000467 CD21                <1>     int 21h
   395                              <1> ;Print the current path of the cds upto the backslash offset
   396 00000469 53                  <1>     push rbx
   397 0000046A 51                  <1>     push rcx
   398 0000046B 488D17              <1>     lea rdx, qword [rdi + cds.sCurrentPath]
   399 0000046E B812120000          <1>     mov eax, 1212h  ;Strlen (rdi points to the current path)
   400 00000473 CD2F                <1>     int 2fh
   401 00000475 BB01000000          <1>     mov ebx, 1          ;Print to STDOUT
   402 0000047A B800400000          <1>     mov eax, 4000h
   403 0000047F CD21                <1>     int 21h
   404 00000481 59                  <1>     pop rcx
   405 00000482 5B                  <1>     pop rbx
   406                              <1> ;Print a CRLF
   407 00000483 488D159E000000      <1>     lea rdx, crlf
   408 0000048A B800090000          <1>     mov eax, 0900h
   409 0000048F CD21                <1>     int 21h
   410                              <1> .gotoNextCDS:
   411 00000491 4881C75F000000      <1>     add rdi, cds_size
   412 00000498 FFC3                <1>     inc ebx ;Goto next drive letter!
   413 0000049A FFC9                <1>     dec ecx
   414 0000049C 75B3                <1>     jnz .lp
   415                              <1> exit:
   416                              <1>     ;call exitDOSCrit
   417 0000049E B8004C0000          <1>     mov eax, 4C00h
   418 000004A3 CD21                <1>     int 21h
   419                              <1> 
   420                              <1> ;------------------------------------------------------------------------
   421                              <1> ; Utility functions below!
   422                              <1> ;------------------------------------------------------------------------
   423                              <1> checkSwitchOk:
   424                              <1> ;Checks if the switch char is D and if the char following is a 
   425                              <1> ; delimiter or CR. 
   426                              <1> ;Input: rsi -> Possible /D. Points to the /
   427                              <1> ;Output: CF=CY: Not ok to proceed.
   428                              <1> ;        CF=NC: Ok to proceed
   429 000004A5 8A4601              <1>     mov al, byte [rsi + 1]
   430 000004A8 50                  <1>     push rax
   431 000004A9 B813120000          <1>     mov eax, 1213h  ;UC char
   432 000004AE CD2F                <1>     int 2Fh
   433 000004B0 3C44                <1>     cmp al, "D"
   434 000004B2 58                  <1>     pop rax
   435 000004B3 750F                <1>     jne .bad
   436 000004B5 8A4602              <1>     mov al, byte [rsi + 2]
   437 000004B8 3C0D                <1>     cmp al, CR  ;If equal, clears CF
   438                              <1>     rete
    49                              <2> cret e
    19                              <3> %%_base:
    20                              <3> %assign baseVar %%_base-$$
    21                              <3>  %ifdef retOff
    22                              <3>  %if (baseVar - retOff <= 126) && (baseVar > retOff)
    23                              <3>  %ifdef currSegVBase
    24                              <3>  j%+1 short (retOff+currSegVBase)
    25                              <3>  %else
    26 000004BA 74(3C)              <3>  j%+1 short retOff
    27                              <3>  %endif
    28                              <3>  %else
    29                              <3>  j%-1 short %%a
    30                              <3>  return
    31                              <3> %%a:
    32                              <3>  %endif
    33                              <3>  %else
    34                              <3>  j%-1 short %%a
    35                              <3>  return
    36                              <3> %%a:
    37                              <3>  %endif
   439 000004BC E821000000          <1>     call isALDelim  ;If return equal, we are ok!
   440                              <1>     rete
    49                              <2> cret e
    19                              <3> %%_base:
    20                              <3> %assign baseVar %%_base-$$
    21                              <3>  %ifdef retOff
    22                              <3>  %if (baseVar - retOff <= 126) && (baseVar > retOff)
    23                              <3>  %ifdef currSegVBase
    24                              <3>  j%+1 short (retOff+currSegVBase)
    25                              <3>  %else
    26                              <3>  j%+1 short retOff
    27                              <3>  %endif
    28                              <3>  %else
    29 000004C1 7501                <3>  j%-1 short %%a
    30                              <3>  return
    13                              <4> %%_ret:
    14 000004C3 C3                  <4>  ret
    15                              <4> %assign retOff %%_ret-$$
    31                              <3> %%a:
    32                              <3>  %endif
    33                              <3>  %else
    34                              <3>  j%-1 short %%a
    35                              <3>  return
    36                              <3> %%a:
    37                              <3>  %endif
   441                              <1> .bad:
   442 000004C4 F9                  <1>     stc
   443                              <1>     return
    13                              <2> %%_ret:
    14 000004C5 C3                  <2>  ret
    15                              <2> %assign retOff %%_ret-$$
   444                              <1> 
   445                              <1> ;enterDOSCrit:
   446                              <1> ;    push rax
   447                              <1> ;    mov eax, 8001h
   448                              <1> ;    int 2Ah
   449                              <1> ;    pop rax
   450                              <1> ;    return 
   451                              <1> 
   452                              <1> ;exitDOSCrit:
   453                              <1> ;    push rax
   454                              <1> ;    mov eax, 8101h
   455                              <1> ;    int 2Ah
   456                              <1> ;    pop rax
   457                              <1> ;    return 
   458                              <1> 
   459                              <1> skipDelims:
   460                              <1> ;Points rsi to the first non-delimiter char in a string, loads al with value
   461 000004C6 AC                  <1>     lodsb
   462 000004C7 E816000000          <1>     call isALDelim
   463 000004CC 74F8                <1>     jz skipDelims
   464                              <1> ;Else, point rsi back to that char :)
   465 000004CE 48FFCE              <1>     dec rsi
   466                              <1>     return
    13                              <2> %%_ret:
    14 000004D1 C3                  <2>  ret
    15                              <2> %assign retOff %%_ret-$$
   467                              <1> 
   468                              <1> findDelimOrCR:
   469                              <1> ;Point rsi to the first delim or cmdtail terminator, loads al with value
   470 000004D2 AC                  <1>     lodsb
   471 000004D3 E806000000          <1>     call isALDelimOrCR
   472 000004D8 75F8                <1>     jnz findDelimOrCR
   473 000004DA 48FFCE              <1>     dec rsi ;Point back to the delim or CR char
   474                              <1>     return
    13                              <2> %%_ret:
    14 000004DD C3                  <2>  ret
    15                              <2> %assign retOff %%_ret-$$
   475                              <1> 
   476                              <1> isALDelimOrCR:
   477 000004DE 3C0D                <1>     cmp al, CR
   478                              <1>     rete
    49                              <2> cret e
    19                              <3> %%_base:
    20                              <3> %assign baseVar %%_base-$$
    21                              <3>  %ifdef retOff
    22                              <3>  %if (baseVar - retOff <= 126) && (baseVar > retOff)
    23                              <3>  %ifdef currSegVBase
    24                              <3>  j%+1 short (retOff+currSegVBase)
    25                              <3>  %else
    26 000004E0 74(DD)              <3>  j%+1 short retOff
    27                              <3>  %endif
    28                              <3>  %else
    29                              <3>  j%-1 short %%a
    30                              <3>  return
    31                              <3> %%a:
    32                              <3>  %endif
    33                              <3>  %else
    34                              <3>  j%-1 short %%a
    35                              <3>  return
    36                              <3> %%a:
    37                              <3>  %endif
   479                              <1> isALDelim:
   480 000004E2 3C20                <1>     cmp al, SPC
   481                              <1>     rete
    49                              <2> cret e
    19                              <3> %%_base:
    20                              <3> %assign baseVar %%_base-$$
    21                              <3>  %ifdef retOff
    22                              <3>  %if (baseVar - retOff <= 126) && (baseVar > retOff)
    23                              <3>  %ifdef currSegVBase
    24                              <3>  j%+1 short (retOff+currSegVBase)
    25                              <3>  %else
    26 000004E4 74(DD)              <3>  j%+1 short retOff
    27                              <3>  %endif
    28                              <3>  %else
    29                              <3>  j%-1 short %%a
    30                              <3>  return
    31                              <3> %%a:
    32                              <3>  %endif
    33                              <3>  %else
    34                              <3>  j%-1 short %%a
    35                              <3>  return
    36                              <3> %%a:
    37                              <3>  %endif
   482 000004E6 3C09                <1>     cmp al, TAB
   483                              <1>     rete
    49                              <2> cret e
    19                              <3> %%_base:
    20                              <3> %assign baseVar %%_base-$$
    21                              <3>  %ifdef retOff
    22                              <3>  %if (baseVar - retOff <= 126) && (baseVar > retOff)
    23                              <3>  %ifdef currSegVBase
    24                              <3>  j%+1 short (retOff+currSegVBase)
    25                              <3>  %else
    26 000004E8 74(DD)              <3>  j%+1 short retOff
    27                              <3>  %endif
    28                              <3>  %else
    29                              <3>  j%-1 short %%a
    30                              <3>  return
    31                              <3> %%a:
    32                              <3>  %endif
    33                              <3>  %else
    34                              <3>  j%-1 short %%a
    35                              <3>  return
    36                              <3> %%a:
    37                              <3>  %endif
   484 000004EA 3C3D                <1>     cmp al, "="
   485                              <1>     rete
    49                              <2> cret e
    19                              <3> %%_base:
    20                              <3> %assign baseVar %%_base-$$
    21                              <3>  %ifdef retOff
    22                              <3>  %if (baseVar - retOff <= 126) && (baseVar > retOff)
    23                              <3>  %ifdef currSegVBase
    24                              <3>  j%+1 short (retOff+currSegVBase)
    25                              <3>  %else
    26 000004EC 74(DD)              <3>  j%+1 short retOff
    27                              <3>  %endif
    28                              <3>  %else
    29                              <3>  j%-1 short %%a
    30                              <3>  return
    31                              <3> %%a:
    32                              <3>  %endif
    33                              <3>  %else
    34                              <3>  j%-1 short %%a
    35                              <3>  return
    36                              <3> %%a:
    37                              <3>  %endif
   486 000004EE 3C2C                <1>     cmp al, ","
   487                              <1>     rete
    49                              <2> cret e
    19                              <3> %%_base:
    20                              <3> %assign baseVar %%_base-$$
    21                              <3>  %ifdef retOff
    22                              <3>  %if (baseVar - retOff <= 126) && (baseVar > retOff)
    23                              <3>  %ifdef currSegVBase
    24                              <3>  j%+1 short (retOff+currSegVBase)
    25                              <3>  %else
    26 000004F0 74(DD)              <3>  j%+1 short retOff
    27                              <3>  %endif
    28                              <3>  %else
    29                              <3>  j%-1 short %%a
    30                              <3>  return
    31                              <3> %%a:
    32                              <3>  %endif
    33                              <3>  %else
    34                              <3>  j%-1 short %%a
    35                              <3>  return
    36                              <3> %%a:
    37                              <3>  %endif
   488 000004F2 3C3B                <1>     cmp al, ";"
   489                              <1>     return
    13                              <2> %%_ret:
    14 000004F4 C3                  <2>  ret
    15                              <2> %assign retOff %%_ret-$$
    20                                  %include "./dat/strings.asm"
     1                              <1> 
     2                              <1> ;SUBST data
     3                              <1> ;Strings
     4 000004F5 43616E6E6F74204A4F- <1> badNetStr   db "Cannot JOIN a network drive",CR,LF,"$"
     4 000004FE 494E2061206E657477- <1>
     4 00000507 6F726B206472697665- <1>
     4 00000510 0D0A24              <1>
     5 00000513 496E636F7272656374- <1> badVerStr   db "Incorrect DOS Version"    ;Ends on the next line
     5 0000051C 20444F532056657273- <1>
     5 00000525 696F6E              <1>
     6 00000528 0A0D24              <1> crlf        db LF,CR,"$"
     7 0000052B 496E636F7272656374- <1> badPrmsStr  db "Incorrect number of parameters",CR,LF,"$"
     7 00000534 206E756D626572206F- <1>
     7 0000053D 6620706172616D6574- <1>
     7 00000546 6572730D0A24        <1>
     8 0000054C 496E76616C69642070- <1> badParmStr  db "Invalid parameter",CR,LF,"$"
     8 00000555 6172616D657465720D- <1>
     8 0000055E 0A24                <1>
     9 00000560 50617468206E6F7420- <1> badPathStr  db "Path not found",CR,LF,"$"
     9 00000569 666F756E640D0A24    <1>
    10 00000571 4469726563746F7279- <1> badDirStr   db "Directory not empty",CR,LF,"$"
    10 0000057A 206E6F7420656D7074- <1>
    10 00000583 790D0A24            <1>
    11 00000587 5F3A203D3E2024      <1> rocketStr   db "_: => $"
    12 0000058E 43616E6E6F74207275- <1> badMultStr  db "Cannot run JOIN in a multitasking environment",CR,LF,"$"
    12 00000597 6E204A4F494E20696E- <1>
    12 000005A0 2061206D756C746974- <1>
    12 000005A9 61736B696E6720656E- <1>
    12 000005B2 7669726F6E6D656E74- <1>
    12 000005BB 0D0A24              <1>
    21                                  ;Use a 45 QWORD stack
    22                                  Segment transient align=8 follows=.text nobits
    23                                  %include "./dat/bss.asm"
     1                              <1> ;BSS data
     2                              <1> bssStart:
     3 00000000 ????????????????    <1> pSysvars    dq ?
     4 00000008 ????????????????    <1> pVar1       dq ?
     5 00000010 ????????????????    <1> pVar2       dq ?
     6                              <1> ;Used for create subst
     7 00000018 ??                  <1> mntDrv  db ?    ;0 based drive number of the JOIN host (mount drive)
     8 00000019 ??                  <1> joinDrv db ?    ;0 based drive number of the joined drive
     9 0000001A <res 5Fh>           <1> inCDS   db cds_size dup (?)
    10 00000079 <res 21h>           <1>         db (128 - cds_size) dup (?)   ;Padding for if the string is too long!
    11 0000009A <res 28h>           <1> srchBuf db 40 dup (?)   ;Allocate double the space  
    12 000000C2 ??                  <1> mntLen  db ?
    13                              <1> 
    14                              <1> bssLen equ $ - bssStart
    24 000000C3 <res 168h>                  dq 45 dup (?)
    25                                  endOfAlloc:
    25          ------------------       info: assembly required 1+3+2 passes

